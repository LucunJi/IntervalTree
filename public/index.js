(()=>{"use strict";const e=jQuery,t=JXG;function s(e,t){return Math.random()*(t-e)+e}function i(e){return e.point1.coords.usrCoords[1]<e.point2.coords.usrCoords[1]?{left:e.point1,right:e.point2}:{left:e.point2,right:e.point1}}function o(e){const t=i(e);return{left:t.left.coords.usrCoords[1],right:t.right.coords.usrCoords[1],range:t.right.coords.usrCoords[1]-t.left.coords.usrCoords[1]}}function r(e,t){const s=i(e),o=s.left.coords.usrCoords[1];return t>s.right.coords.usrCoords[1]?-1:t<o?1:0}class n{constructor(){this.listeners=Object(null)}on(e,t){var s,i;(null!==(s=(i=this.listeners)[e])&&void 0!==s?s:i[e]=[]).push(t)}notify(e,t){var s;null===(s=this.listeners[e])||void 0===s||s.forEach((e=>e(t)))}}const d=sdsl;function h(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>e.suspendUpdate())),t(),e.forEach((e=>e.unsuspendUpdate()))}const a="#0072b2",l="#c25010",c="#1f1f1f",u="#1f1f1f";class g extends n{constructor(e){super(),this.acceptChanges=!0,this.segments=[],this.sortingEnd="left",this.medians=new Map,this.segmentVisibleMedians=new Map,this.startAddingSegmentFunction=e=>{if(this.board.getAllObjectsUnderMouse(e).length>0)return;const t=this.board.getUsrCoordsOfMouse(e);this.creatingLine=this.newSegment(t,t)},this.moveEndpointWhenAddingFunction=e=>{if(void 0!==this.creatingLine){const t=this.board.getUsrCoordsOfMouse(e);this.creatingLine.p1.setPosition(JXG.COORDS_BY_USER,[this.creatingLine.p1.coords.usrCoords[1],t[1]]),this.creatingLine.p2.setPosition(JXG.COORDS_BY_USER,t),this.board.update()}},this.releaseAddingSegmentFunction=()=>{this.creatingLine=void 0},this.board=t.JSXGraph.initBoard(e,{boundingbox:[-10,10,10,-10],showCopyright:!1,showNavigation:!1,pan:{enabled:!1},zoom:{wheel:!1}}),this.board.on("down",this.startAddingSegmentFunction),this.board.on("move",this.moveEndpointWhenAddingFunction),this.board.on("up",this.releaseAddingSegmentFunction),this.queryLine=this.board.create("line",[[0,0],[0,1]],{visible:!1,fixed:!1,strokeColor:"#000",dragToTopOfLayer:!0,strokeOpacity:.5,strokeWidth:3}),this.queryLine.on("up",(()=>this.notify("queryLineChange",this.queryLine.point1.coords.usrCoords[1])))}newSegment(e,t){if(!this.acceptChanges)throw new Error("Board is frozen, new segments are not accepted.");const s=this.board.create("point",e,{withLabel:!1,color:l}),i=this.board.create("point",t,{withLabel:!1,color:l}),o=this.board.create("segment",[s,i],{strokeColor:a});return s.on("drag",(()=>i.setPosition(JXG.COORDS_BY_USER,[i.coords.usrCoords[1],s.coords.usrCoords[2]]))),i.on("drag",(()=>s.setPosition(JXG.COORDS_BY_USER,[s.coords.usrCoords[1],i.coords.usrCoords[2]]))),this.segments.push(o),this.segmentVisibleMedians.set(o.id,new d.LinkList),this.notify("newSegment",{p1:s,p2:i,l:o}),{p1:s,p2:i,l:o}}sortSegments(){if(1===this.segments.length){const e=this.segments[0],t=0;return e.point1.moveTo([e.point1.coords.usrCoords[1],t],400),void e.point2.moveTo([e.point2.coords.usrCoords[1],t],400)}const e=[],t=[];for(let t=0;t<this.segments.length;t++)e.push(t);"left"===this.sortingEnd?e.sort(((e,t)=>o(this.segments[e]).left-o(this.segments[t]).left)):e.sort(((e,t)=>o(this.segments[t]).right-o(this.segments[e]).right));for(let s=0;s<this.segments.length;s++)t[e[s]]=s;const s=18/(this.segments.length-1);for(let e=0;e<this.segments.length;e++){const i=this.segments[e],o=9-s*t[e];i.point1.moveTo([i.point1.coords.usrCoords[1],o],400),i.point2.moveTo([i.point2.coords.usrCoords[1],o],400)}}finalizeChanges(){this.acceptChanges&&(this.acceptChanges=!1,this.board.off("down",this.startAddingSegmentFunction),this.board.off("move",this.moveEndpointWhenAddingFunction),this.board.off("up",this.releaseAddingSegmentFunction),h(this.board,(()=>{for(let e=0;e<this.segments.length;e++){const t=this.segments[e];t.setAttribute({strokeColor:c,fixed:!0}),t.point1.setAttribute({color:u,fixed:!0}),t.point2.setAttribute({color:u,fixed:!0})}})),this.sortSegments())}getSegments(){return this.segments}populateSegments(e){const t=18/(e+1);for(let i=0;i<e;i++){const e=t*(i+1)-9;let o,r;do{o=s(-9.5,9.5),r=s(-9.5,9.5)}while(Math.abs(o-r)<.76);this.newSegment([o,e],[r,e])}}addMedian(e,t,s,i=!1,o=e){if(this.medians.has(o))return!1;const r={strokeColor:s,dash:2,visible:!1,fixed:!0},n=this.board.create("line",[[e,0],[e,1]],r);return this.medians.set(o,{line:n,relatedSegments:t,color:s}),this.setMedianVisible(o,i),!0}removeMedian(e){const t=this.medians.get(e);return void 0!==t&&(this.setMedianVisible(e,!1),this.board.removeObject(t.line),this.medians.delete(e),!0)}setMedianVisible(e,t){const s=this.medians.get(e);if(void 0!==s&&s.line.getAttribute("visible")!==t){console.log("setvisible",e,s.color,t),s.line.setAttribute({visible:t});for(const i of s.relatedSegments){const s=this.segmentVisibleMedians.get(i.id);t?s.pushBack(e):s.eraseElementByValue(e);let o=this.acceptChanges?a:c,r=this.acceptChanges?l:u;const n=s.back();void 0!==n&&(o=r=this.medians.get(n).color),i.setAttribute({strokeColor:o}),i.point1.setAttribute({color:r}),i.point2.setAttribute({color:r})}}}setSortingEnd(e){this.sortingEnd!==e&&(this.sortingEnd=e,this.acceptChanges||this.sortSegments())}showQueryLine(){this.queryLine.setAttribute({visible:!0})}getQuery(){return this.queryLine.point1.coords.usrCoords[1]}}class f{constructor(e){if(this.nodes=[],0===e.length)throw new Error("Input array is empty");const t=e.slice().sort(((e,t)=>o(e).left-o(t).left)),s=e.slice().sort(((e,t)=>o(t).right-o(e).right));this.root=f.makeNode(void 0,t,s,0),this.height=this.root.height;for(const e of this.bfs())this.nodes[(1<<e.depth)-1+e.peerIdx]=e}static makeNode(e,t,s,i){if(0===t.length)return;const o=f.medianPoint(t,s),{l:r,m:n,r:d}=f.splitSegmentList(t,o),{l:h,m:a,r:l}=f.splitSegmentList(t,o),c={parent:e,depth:void 0===e?0:e.depth+1,height:1,peerIdx:i,median:o,segmentsLeftSorted:n,segmentsRightSorted:a};return c.childLeft=this.makeNode(c,r,d,2*i),c.childRight=this.makeNode(c,h,l,2*i+1),void 0!==c.childLeft&&(c.height=c.childLeft.height+1),void 0!==c.childRight&&(c.height=Math.max(c.height,c.childRight.height+1)),c}static medianPoint(e,t){const s=e.length;let o=0,r=0,n=s-1;for(let d=0;d<s;d++){const d=r>=s?void 0:i(e[r]).left.coords.usrCoords[1],h=n<0?void 0:i(t[n]).right.coords.usrCoords[1];void 0===h||d<h?(o=d,r++):(o=h,n--)}return o}static splitSegmentList(e,t){const s={l:[],m:[],r:[]};for(const i of e){const e=r(i,t);(e<0?s.l:0===e?s.m:s.r).push(i)}return s}*bfs(){const e=new d.Queue;for(e.push(this.root);e.size()>0;){const t=e.pop();void 0!==t.childLeft&&e.push(t.childLeft),void 0!==t.childRight&&e.push(t.childRight),yield t}}}class b{constructor(e,t){this.graph=e,this.index=t}canSimulate(e){return void 0!==this.graph[this.index].actionIdx[e]}simulate(e){this.canSimulate(e)&&(this.index=this.graph[this.index].actionIdx[e])}currentNode(){return this.graph[this.index]}}class p{constructor(e,t,s,i={},o=e.segmentsLeftSorted){this.treeNode=e,this.leftFinished=t,this.rightFinished=s,this.actionIdx=i,this.involvedSegs=o}}class m extends b{constructor(e){super(m.buildGraph(e.root),0)}static buildGraph(e){const t=[];return m.buildGraphRecursive(t,e).slice(0,-1).forEach((e=>e.actionIdx.finishSubtree=t.length-1)),t}static buildGraphRecursive(e,t){var s;const i=null!==(s=t.childLeft)&&void 0!==s?s:t.childRight,o=void 0!==t.childLeft,r=void 0!==t.childLeft&&void 0!==t.childRight,n=[new p(t,!1,!1)],d=[];n.push(),void 0!==i&&(n.push(new p(t,o,!o)),d[1]=i),r&&(n.push(new p(t,!0,!0)),d[2]=t.childRight);let h=-1;return n.forEach(((t,s)=>{s>0&&(e[h].actionIdx.recurse=e.length,this.buildGraphRecursive(e,d[s]).forEach((t=>{t.actionIdx.undoRecurse=h,t.actionIdx.finishSubtree=e.length}))),h=e.push(t)-1})),n}}class v extends b{constructor(e,t){super(v.buildGraph(e.root,t),0)}static buildGraph(e,t){const s=[];let i=e;do{s.length>0&&(s[s.length-1].actionIdx.recurse=s.length);const e=s.length>0?s.length-1:void 0;let r,n;t<i.median?(r=i.segmentsLeftSorted.filter((e=>o(e).left<=t)),n=i.childLeft):t>i.median?(r=i.segmentsLeftSorted.filter((e=>o(e).right>=t)),n=i.childRight):r=i.segmentsLeftSorted.slice(),s.push(new p(i,!1,!1,{undoRecurse:e},r)),i=n}while(void 0!==i);return s}}class S extends n{constructor(){super(...arguments),this.state="draw"}setState(e){if(this.state===e)return;const t=this.state;this.state=e,this.notify("stateChange",{state:e,prevState:t})}notifyAlgoReset(e,t){this.notify("algorithmReset",{simState:this.state,algoState:e.currentNode(),tree:t})}getState(){return this.state}build(e){this.tree=new f(e),this.simulator=new m(this.tree),this.setState("build"),this.notifyAlgoReset(this.simulator,this.tree)}query(e){if(void 0===this.tree)throw new Error("Tree is not built before query");this.simulator=new v(this.tree,e),this.setState("query"),this.notifyAlgoReset(this.simulator,this.tree)}canSimulate(e){return void 0!==this.simulator&&this.simulator.canSimulate(e)}simulate(e){if(!this.canSimulate(e))return;const t=this.simulator,s=t.index;t.simulate(e);const i=t.index,o=new Map;for(let e=Math.min(s,i)+1;e<=Math.max(s,i);e++)o.set(t.graph[e].treeNode,t.graph[e].involvedSegs);this.notify("algorithmStateChange",{currState:t.currentNode(),addedTreeNodesSegs:i<s?new Map:o,removedTreeNodesSegs:i<s?o:new Map})}}class C{constructor(){this.paletteIdx=0}get(){const e=C.PALETTE[this.paletteIdx%C.PALETTE.length];return this.paletteIdx++,e}}C.PALETTE=["#bc0101","#ffd700","#ea5f94","#ff7300","#11b716","#10d5a8","#0000ff","#9d02d7"];class w extends n{constructor(e,s){super(),this.nodes=[],this.edges=[],this.board=t.JSXGraph.initBoard(e,{boundingbox:[-10,10,10,-10],showCopyright:!1,drag:{enabled:!1},pan:{enabled:!0,needShift:!1,needTwoFingers:!1},zoom:{wheel:!0,needShift:!1}}),this.tree=s,this.drawTree(),this.board.on("move",(()=>{const e=this.hoveringNode;this.hoveringNode=void 0;for(let e=0;e<this.nodes.length;e++){const t=this.nodes[e];if(void 0!==t&&t.mouseover){this.hoveringNode=this.tree.nodes[e];break}}this.hoveringNode!==e&&this.notify("hoverNode",{node:this.hoveringNode,prevNode:e})}))}drawTree(){if(1===this.tree.height){const e=[0,0];return void(this.nodes[0]=this.board.create("point",e,{size:.5,sizeUnit:"user",withLabel:!1,strokeWidth:4,color:(new C).get()}))}const e=16/(this.tree.height-1),t=this.tree.nodes.map(((e,t)=>void 0===e?void 0:t)).filter((e=>void 0!==e)).sort(((e,t)=>this.tree.nodes[e].median-this.tree.nodes[t].median)),s=[],i=new C;for(const e of t)s[e]=i.get();for(let t=0;t<this.tree.height;t++){const i=8-t*e,o=1<<t,r=19/(o+1);for(let e=0;e<o;e++){const t=o-1+e,n=[r*(e+1)-9.5,i];void 0!==this.tree.nodes[t]&&(this.nodes[t]=this.board.create("point",n,{size:.5,sizeUnit:"user",withLabel:!1,strokeWidth:4,color:s[t]}),t>0&&(this.edges[t]=this.board.create("line",[this.nodes[t],this.nodes[t-1>>>1]],{straightFirst:!1,straightLast:!1})))}}}setNodeVisible(e,t){var s,i;const o=(1<<e.depth)-1+e.peerIdx;null===(s=this.nodes[o])||void 0===s||s.setAttribute({visible:t}),null===(i=this.edges[o])||void 0===i||i.setAttribute({visible:t})}setNodeAncestorsVisible(e,t){for(var s,i;void 0!==e;){const o=(1<<e.depth)-1+e.peerIdx;null===(s=this.nodes[o])||void 0===s||s.setAttribute({visible:t}),null===(i=this.edges[o])||void 0===i||i.setAttribute({visible:t}),e=e.parent}}setChildrenVisible(e,t){this.setSubtreeVisible(null==e?void 0:e.childLeft,t),this.setSubtreeVisible(null==e?void 0:e.childRight,t)}setSubtreeVisible(e,t){var s,i;if(void 0===e)return;const o=(1<<e.depth)-1+e.peerIdx;null===(s=this.nodes[o])||void 0===s||s.setAttribute({visible:t}),null===(i=this.edges[o])||void 0===i||i.setAttribute({visible:t}),this.setSubtreeVisible(e.childLeft,t),this.setSubtreeVisible(e.childRight,t)}setNodeHollow(e,t){var s;void 0!==e&&(null===(s=this.graphNode(e))||void 0===s||s.setAttribute({fillOpacity:t?0:1}))}focusNode(e){this.setNodeHollow(this.focusedNode,!1),this.setNodeHollow(this.focusedNode=e,!0)}graphNode(e){return this.nodes[(1<<e.depth)-1+e.peerIdx]}}e((()=>{const t=new S,s=new g("plotboard");let i;function o(e,t){s.setMedianVisible(e.median,t),null==i||i.setNodeVisible(e,t)}function r(e,t,o){const r=i.graphNode(e).getAttribute("strokeColor");o?s.addMedian(e.median,t,r,!0,e.median+"query"):s.removeMedian(e.median+"query")}!function(){const i=e("#populate").on("submit",(t=>{s.populateSegments(parseInt(e("#populate-count").val())),t.preventDefault()}));t.on("stateChange",(e=>i.find(":input").prop("disabled","draw"!==e.state)))}(),function(){const i=e("[name=sort-endpoint]").each(((t,i)=>{e(i).on("change",(t=>s.setSortingEnd(e(t.target).val())))})).prop("disabled",!0);s.setSortingEnd(i.find(":checked").val()),t.on("stateChange",(e=>{i.prop("disabled","draw"!==e.state)}))}(),function(){const i={all:e("#algo-buttons button"),start:e("#algo-start"),recurse:e("#algo-recurse"),undoRecurse:e("#algo-undo-recurse"),finishSubtree:e("#algo-finish-subtree")};function o(){i.recurse.prop("disabled",!t.canSimulate("recurse")),i.undoRecurse.prop("disabled",!t.canSimulate("undoRecurse")),i.finishSubtree.prop("disabled",!t.canSimulate("finishSubtree"))}i.all.prop("disabled",!0),s.on("newSegment",(()=>i.start.prop("disabled",!1))),t.on("algorithmReset",o),t.on("algorithmStateChange",o),t.on("stateChange",(e=>{switch(e.state){case"draw":i.start.html("Start Building"),i.start.removeClass("btn-outline-danger"),i.start.addClass('btn-outline-primary"');break;case"build":i.start.html("Start Query"),i.start.removeClass("btn-outline-danger"),i.start.addClass('btn-outline-primary"');break;case"query":i.start.html("Reset"),i.start.removeClass('btn-outline-primary"'),i.start.addClass("btn-outline-danger")}})),i.start.on("click",(()=>{const e=t.getState();"draw"===e&&s.getSegments().length>0?t.build(s.getSegments()):"build"===e?t.query(s.getQuery()):window.location.reload()})),i.recurse.on("click",(()=>t.simulate("recurse"))),i.undoRecurse.on("click",(()=>t.simulate("undoRecurse"))),i.finishSubtree.on("click",(()=>t.simulate("finishSubtree")))}(),t.on("stateChange",(e=>{"build"===e.state?(s.finalizeChanges(),void 0===i&&(i=new w("treeboard",t.tree),i.on("hoverNode",(e=>{h(s.board,(()=>{if(void 0!==e.prevNode&&s.removeMedian("hover"),void 0!==e.node){const t=i.graphNode(e.node).getAttribute("highlightFillColor");s.addMedian(e.node.median,e.node.segmentsLeftSorted,t,!0,"hover")}}))}))),h(i.board,(()=>{null==i||i.setSubtreeVisible(t.tree.root,!1),null==i||i.setNodeVisible(t.tree.root,!0)}))):"query"===e.state&&(h(s.board,(()=>{for(const e of t.tree.bfs())s.setMedianVisible(e.median,!1)})),s.showQueryLine(),h(i.board,(()=>i.setSubtreeVisible(t.tree.root,!0))))})),t.on("algorithmReset",(e=>{var t;if("build"===e.simState){const o=new C;for(const r of e.tree.bfs()){const e=null!==(t=null==i?void 0:i.graphNode(r).getAttribute("strokeColor"))&&void 0!==t?t:o.get();s.addMedian(r.median,r.segmentsLeftSorted,e)}h(s.board,(()=>s.setMedianVisible(e.algoState.treeNode.median,!0))),null==i||i.focusNode(e.algoState.treeNode)}else"query"===e.simState&&h(s.board,(()=>{for(const t of e.tree.bfs())r(t,[],!1);r(e.algoState.treeNode,e.algoState.involvedSegs,!0)}))})),t.on("algorithmStateChange",(e=>{switch(t.getState()){case"build":h([i.board,s.board],(()=>{i.focusNode(e.currState.treeNode),e.addedTreeNodesSegs.forEach(((e,t)=>o(t,!0))),e.removedTreeNodesSegs.forEach(((e,t)=>o(t,!1)))}));break;case"query":h(s.board,(()=>{e.addedTreeNodesSegs.forEach(((e,t)=>r(t,e,!0))),e.removedTreeNodesSegs.forEach(((e,t)=>r(t,e,!1)))})),i.focusNode(e.currState.treeNode)}})),s.on("queryLineChange",(e=>t.query(e)))}))})();